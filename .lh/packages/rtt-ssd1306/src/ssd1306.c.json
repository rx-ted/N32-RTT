{
    "sourceFile": "packages/rtt-ssd1306/src/ssd1306.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 36,
            "patches": [
                {
                    "date": 1673770639404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1673771243419,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,11 +32,9 @@\n \r\n // Send a byte to the command register\r\n void ssd1306_WriteCommand(uint8_t byte) \r\n {\r\n-#if PKG_USING_SSD1306_HW_I2C\r\n-    HAL_I2C_Mem_Write(&SSD1306_I2C_PORT, SSD1306_I2C_ADDR, 0x00, 1, &byte, 1, HAL_MAX_DELAY);\r\n-#else\r\n+\r\n     uint8_t buf[2] = {SSD1306_CTRL_CMD, byte};\r\n     rt_i2c_master_send(i2c_bus, SSD1306_I2C_ADDR, RT_I2C_WR, buf, 2);\r\n #endif\r\n }\r\n"
                },
                {
                    "date": 1673771272197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,9 @@\n     {\r\n         uint8_t buf[2] = {SSD1306_CTRL_DATA, buffer[i]};\r\n         rt_i2c_master_send(i2c_bus, SSD1306_I2C_ADDR, RT_I2C_WR, buf, 2);\r\n     }\r\n-#endif\r\n+\r\n }\r\n \r\n #elif defined(SSD1306_USE_SPI)\r\n \r\n"
                },
                {
                    "date": 1673771278863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,62 +35,23 @@\n {\r\n \r\n     uint8_t buf[2] = {SSD1306_CTRL_CMD, byte};\r\n     rt_i2c_master_send(i2c_bus, SSD1306_I2C_ADDR, RT_I2C_WR, buf, 2);\r\n-#endif\r\n }\r\n \r\n // Send data\r\n void ssd1306_WriteData(uint8_t* buffer, size_t buff_size) \r\n {\r\n-#if PKG_USING_SSD1306_HW_I2C\r\n-    HAL_I2C_Mem_Write(&SSD1306_I2C_PORT, SSD1306_I2C_ADDR, 0x40, 1, buffer, buff_size, HAL_MAX_DELAY);\r\n-#else\r\n+\r\n     for (int i=0; i<buff_size; i++)\r\n     {\r\n         uint8_t buf[2] = {SSD1306_CTRL_DATA, buffer[i]};\r\n         rt_i2c_master_send(i2c_bus, SSD1306_I2C_ADDR, RT_I2C_WR, buf, 2);\r\n     }\r\n \r\n }\r\n \r\n-#elif defined(SSD1306_USE_SPI)\r\n \r\n-void ssd1306_Reset(void) \r\n-{\r\n-    // CS = High (not selected)\r\n-    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_SET);\r\n-\r\n-    // Reset the OLED\r\n-    HAL_GPIO_WritePin(SSD1306_Reset_Port, SSD1306_Reset_Pin, GPIO_PIN_RESET);\r\n-    rt_thread_mdelay(10);\r\n-    HAL_GPIO_WritePin(SSD1306_Reset_Port, SSD1306_Reset_Pin, GPIO_PIN_SET);\r\n-    rt_thread_mdelay(10);\r\n-}\r\n-\r\n-// Send a byte to the command register\r\n-void ssd1306_WriteCommand(uint8_t byte) \r\n-{\r\n-    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_RESET); // select OLED\r\n-    HAL_GPIO_WritePin(SSD1306_DC_Port, SSD1306_DC_Pin, GPIO_PIN_RESET); // command\r\n-    HAL_SPI_Transmit(&SSD1306_SPI_PORT, (uint8_t *) &byte, 1, HAL_MAX_DELAY);\r\n-    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_SET); // un-select OLED\r\n-}\r\n-\r\n-// Send data\r\n-void ssd1306_WriteData(uint8_t* buffer, size_t buff_size) \r\n-{\r\n-    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_RESET); // select OLED\r\n-    HAL_GPIO_WritePin(SSD1306_DC_Port, SSD1306_DC_Pin, GPIO_PIN_SET); // data\r\n-    HAL_SPI_Transmit(&SSD1306_SPI_PORT, buffer, buff_size, HAL_MAX_DELAY);\r\n-    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_SET); // un-select OLED\r\n-}\r\n-\r\n-#else\r\n-#error \"You should define SSD1306_USE_SPI or SSD1306_USE_I2C macro\"\r\n-#endif\r\n-\r\n-\r\n // Screenbuffer\r\n static uint8_t SSD1306_Buffer[SSD1306_BUFFER_SIZE];\r\n \r\n // Screen object\r\n"
                },
                {
                    "date": 1673771286495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,10 @@\n #include \"ssd1306.h\"\r\n \r\n #include <rtdbg.h>\r\n \r\n-#if defined(SSD1306_USE_I2C)\r\n \r\n+\r\n #define SSD1306_CTRL_CMD     0x00\r\n #define SSD1306_CTRL_DATA    0x40\r\n #define SSD1306_MASK_CONT    (0x1<<7)\r\n \r\n"
                },
                {
                    "date": 1673771299773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,8 @@\n #include \"ssd1306.h\"\r\n \r\n #include <rtdbg.h>\r\n \r\n-\r\n-\r\n #define SSD1306_CTRL_CMD     0x00\r\n #define SSD1306_CTRL_DATA    0x40\r\n #define SSD1306_MASK_CONT    (0x1<<7)\r\n \r\n@@ -77,10 +75,10 @@\n     {\r\n         LOG_E(\"can not find %s device\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n         return;\r\n     }\r\n-#endif\r\n \r\n+\r\n     // Reset OLED\r\n     ssd1306_Reset();\r\n \r\n     // Wait for the screen to boot\r\n"
                },
                {
                    "date": 1673772279590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,13 +68,13 @@\n \r\n // Initialize the oled screen\r\n void ssd1306_Init(void) \r\n {\r\n-#if defined(SSD1306_USE_I2C)\r\n+\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n     {\r\n-        LOG_E(\"can not find %s device\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n+        rt_kprintf(\"can not find %s device\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n         return;\r\n     }\r\n \r\n \r\n"
                },
                {
                    "date": 1673772455040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,9 +165,9 @@\n     ssd1306_WriteCommand(0x14); //\r\n     ssd1306_SetDisplayOn(1); //--turn on SSD1306 panel\r\n \r\n     // Clear screen\r\n-    ssd1306_Fill(Black);\r\n+    ssd1306_Fill(White);\r\n     \r\n     // Flush buffer to screen\r\n     ssd1306_UpdateScreen();\r\n     \r\n"
                },
                {
                    "date": 1673772527476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,10 +75,12 @@\n     {\r\n         rt_kprintf(\"can not find %s device\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n         return;\r\n     }\r\n+        rt_kprintf(\"can not find %s device\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n \r\n \r\n+\r\n     // Reset OLED\r\n     ssd1306_Reset();\r\n \r\n     // Wait for the screen to boot\r\n"
                },
                {
                    "date": 1673865314055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,515 +0,0 @@\n-/*\r\n- * Copyright (c) 2020, RudyLo <luhuadong@163.com>\r\n- *\r\n- * SPDX-License-Identifier: MIT License\r\n- *\r\n- * Change Logs:\r\n- * Date           Author       Notes\r\n- * 2020-11-15     luhuadong    the first version\r\n- */\r\n-\r\n-#include <rtthread.h>\r\n-#include <rtdevice.h>\r\n-#include <stdlib.h>\r\n-#include <string.h>  // For memcpy\r\n-#include <math.h>\r\n-#include \"ssd1306.h\"\r\n-\r\n-#include <rtdbg.h>\r\n-\r\n-#define SSD1306_CTRL_CMD     0x00\r\n-#define SSD1306_CTRL_DATA    0x40\r\n-#define SSD1306_MASK_CONT    (0x1<<7)\r\n-\r\n-static struct rt_i2c_bus_device *i2c_bus;\r\n-\r\n-void ssd1306_Reset(void) \r\n-{\r\n-    /* for I2C - do nothing */\r\n-}\r\n-\r\n-// Send a byte to the command register\r\n-void ssd1306_WriteCommand(uint8_t byte) \r\n-{\r\n-\r\n-    uint8_t buf[2] = {SSD1306_CTRL_CMD, byte};\r\n-    rt_i2c_master_send(i2c_bus, SSD1306_I2C_ADDR, RT_I2C_WR, buf, 2);\r\n-}\r\n-\r\n-// Send data\r\n-void ssd1306_WriteData(uint8_t* buffer, size_t buff_size) \r\n-{\r\n-\r\n-    for (int i=0; i<buff_size; i++)\r\n-    {\r\n-        uint8_t buf[2] = {SSD1306_CTRL_DATA, buffer[i]};\r\n-        rt_i2c_master_send(i2c_bus, SSD1306_I2C_ADDR, RT_I2C_WR, buf, 2);\r\n-    }\r\n-\r\n-}\r\n-\r\n-\r\n-// Screenbuffer\r\n-static uint8_t SSD1306_Buffer[SSD1306_BUFFER_SIZE];\r\n-\r\n-// Screen object\r\n-static SSD1306_t SSD1306;\r\n-\r\n-/* Fills the Screenbuffer with values from a given buffer of a fixed length */\r\n-SSD1306_Error_t ssd1306_FillBuffer(uint8_t* buf, uint32_t len) \r\n-{\r\n-    SSD1306_Error_t ret = SSD1306_ERR;\r\n-    if (len <= SSD1306_BUFFER_SIZE) {\r\n-        memcpy(SSD1306_Buffer,buf,len);\r\n-        ret = SSD1306_OK;\r\n-    }\r\n-    return ret;\r\n-}\r\n-\r\n-// Initialize the oled screen\r\n-void ssd1306_Init(void) \r\n-{\r\n-\r\n-    i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n-    if (i2c_bus == RT_NULL)\r\n-    {\r\n-        rt_kprintf(\"can not find %s device\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n-        return;\r\n-    }\r\n-        rt_kprintf(\"can not find %s device\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n-\r\n-\r\n-\r\n-    // Reset OLED\r\n-    ssd1306_Reset();\r\n-\r\n-    // Wait for the screen to boot\r\n-    rt_thread_mdelay(100);\r\n-\r\n-    // Init OLED\r\n-    ssd1306_SetDisplayOn(0); //display off\r\n-\r\n-    ssd1306_WriteCommand(0x20); //Set Memory Addressing Mode\r\n-    ssd1306_WriteCommand(0x00); // 00b,Horizontal Addressing Mode; 01b,Vertical Addressing Mode;\r\n-                                // 10b,Page Addressing Mode (RESET); 11b,Invalid\r\n-\r\n-    ssd1306_WriteCommand(0xB0); //Set Page Start Address for Page Addressing Mode,0-7\r\n-\r\n-#ifdef SSD1306_MIRROR_VERT\r\n-    ssd1306_WriteCommand(0xC0); // Mirror vertically\r\n-#else\r\n-    ssd1306_WriteCommand(0xC8); //Set COM Output Scan Direction\r\n-#endif\r\n-\r\n-    ssd1306_WriteCommand(0x00); //---set low column address\r\n-    ssd1306_WriteCommand(0x10); //---set high column address\r\n-\r\n-    ssd1306_WriteCommand(0x40); //--set start line address - CHECK\r\n-\r\n-    ssd1306_SetContrast(0xFF);\r\n-\r\n-#ifdef SSD1306_MIRROR_HORIZ\r\n-    ssd1306_WriteCommand(0xA0); // Mirror horizontally\r\n-#else\r\n-    ssd1306_WriteCommand(0xA1); //--set segment re-map 0 to 127 - CHECK\r\n-#endif\r\n-\r\n-#ifdef SSD1306_INVERSE_COLOR\r\n-    ssd1306_WriteCommand(0xA7); //--set inverse color\r\n-#else\r\n-    ssd1306_WriteCommand(0xA6); //--set normal color\r\n-#endif\r\n-\r\n-// Set multiplex ratio.\r\n-#if (SSD1306_HEIGHT == 128)\r\n-    // Found in the Luma Python lib for SH1106.\r\n-    ssd1306_WriteCommand(0xFF);\r\n-#else\r\n-    ssd1306_WriteCommand(0xA8); //--set multiplex ratio(1 to 64) - CHECK\r\n-#endif\r\n-\r\n-#if (SSD1306_HEIGHT == 32)\r\n-    ssd1306_WriteCommand(0x1F); //\r\n-#elif (SSD1306_HEIGHT == 64)\r\n-    ssd1306_WriteCommand(0x3F); //\r\n-#elif (SSD1306_HEIGHT == 128)\r\n-    ssd1306_WriteCommand(0x3F); // Seems to work for 128px high displays too.\r\n-#else\r\n-#error \"Only 32, 64, or 128 lines of height are supported!\"\r\n-#endif\r\n-\r\n-    ssd1306_WriteCommand(0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content\r\n-\r\n-    ssd1306_WriteCommand(0xD3); //-set display offset - CHECK\r\n-    ssd1306_WriteCommand(0x00); //-not offset\r\n-\r\n-    ssd1306_WriteCommand(0xD5); //--set display clock divide ratio/oscillator frequency\r\n-    ssd1306_WriteCommand(0xF0); //--set divide ratio\r\n-\r\n-    ssd1306_WriteCommand(0xD9); //--set pre-charge period\r\n-    ssd1306_WriteCommand(0x22); //\r\n-\r\n-    ssd1306_WriteCommand(0xDA); //--set com pins hardware configuration - CHECK\r\n-#if (SSD1306_HEIGHT == 32)\r\n-    ssd1306_WriteCommand(0x02);\r\n-#elif (SSD1306_HEIGHT == 64)\r\n-    ssd1306_WriteCommand(0x12);\r\n-#elif (SSD1306_HEIGHT == 128)\r\n-    ssd1306_WriteCommand(0x12);\r\n-#else\r\n-#error \"Only 32, 64, or 128 lines of height are supported!\"\r\n-#endif\r\n-\r\n-    ssd1306_WriteCommand(0xDB); //--set vcomh\r\n-    ssd1306_WriteCommand(0x20); //0x20,0.77xVcc\r\n-\r\n-    ssd1306_WriteCommand(0x8D); //--set DC-DC enable\r\n-    ssd1306_WriteCommand(0x14); //\r\n-    ssd1306_SetDisplayOn(1); //--turn on SSD1306 panel\r\n-\r\n-    // Clear screen\r\n-    ssd1306_Fill(White);\r\n-    \r\n-    // Flush buffer to screen\r\n-    ssd1306_UpdateScreen();\r\n-    \r\n-    // Set default values for screen object\r\n-    SSD1306.CurrentX = 0;\r\n-    SSD1306.CurrentY = 0;\r\n-    \r\n-    SSD1306.Initialized = 1;\r\n-}\r\n-\r\n-// Fill the whole screen with the given color\r\n-void ssd1306_Fill(SSD1306_COLOR color) \r\n-{\r\n-    /* Set memory */\r\n-    uint32_t i;\r\n-\r\n-    for(i = 0; i < sizeof(SSD1306_Buffer); i++) \r\n-    {\r\n-        SSD1306_Buffer[i] = (color == Black) ? 0x00 : 0xFF;\r\n-    }\r\n-}\r\n-\r\n-// Write the screenbuffer with changed to the screen\r\n-void ssd1306_UpdateScreen(void) \r\n-{\r\n-    // Write data to each page of RAM. Number of pages\r\n-    // depends on the screen height:\r\n-    //\r\n-    //  * 32px   ==  4 pages\r\n-    //  * 64px   ==  8 pages\r\n-    //  * 128px  ==  16 pages\r\n-    for(uint8_t i = 0; i < SSD1306_HEIGHT/8; i++) \r\n-    {\r\n-        ssd1306_WriteCommand(0xB0 + i); // Set the current RAM page address.\r\n-        ssd1306_WriteCommand(0x00);\r\n-        ssd1306_WriteCommand(0x10);\r\n-        ssd1306_WriteData(&SSD1306_Buffer[SSD1306_WIDTH*i],SSD1306_WIDTH);\r\n-    }\r\n-}\r\n-\r\n-//    Draw one pixel in the screenbuffer\r\n-//    X => X Coordinate\r\n-//    Y => Y Coordinate\r\n-//    color => Pixel color\r\n-void ssd1306_DrawPixel(uint8_t x, uint8_t y, SSD1306_COLOR color) \r\n-{\r\n-    if(x >= SSD1306_WIDTH || y >= SSD1306_HEIGHT)\r\n-    {\r\n-        // Don't write outside the buffer\r\n-        return;\r\n-    }\r\n-    \r\n-    // Check if pixel should be inverted\r\n-    if(SSD1306.Inverted)\r\n-    {\r\n-        color = (SSD1306_COLOR)!color;\r\n-    }\r\n-    \r\n-    // Draw in the right color\r\n-    if(color == White)\r\n-    {\r\n-        SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] |= 1 << (y % 8);\r\n-    } else\r\n-    {\r\n-        SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] &= ~(1 << (y % 8));\r\n-    }\r\n-}\r\n-\r\n-// Draw 1 char to the screen buffer\r\n-// ch       => char om weg te schrijven\r\n-// Font     => Font waarmee we gaan schrijven\r\n-// color    => Black or White\r\n-char ssd1306_WriteChar(char ch, FontDef Font, SSD1306_COLOR color) \r\n-{\r\n-    uint32_t i, b, j;\r\n-    \r\n-    // Check if character is valid\r\n-    if (ch < 32 || ch > 126)\r\n-        return 0;\r\n-    \r\n-    // Check remaining space on current line\r\n-    if (SSD1306_WIDTH < (SSD1306.CurrentX + Font.FontWidth) ||\r\n-        SSD1306_HEIGHT < (SSD1306.CurrentY + Font.FontHeight))\r\n-    {\r\n-        // Not enough space on current line\r\n-        return 0;\r\n-    }\r\n-    \r\n-    // Use the font to write\r\n-    for(i = 0; i < Font.FontHeight; i++)\r\n-    {\r\n-        b = Font.data[(ch - 32) * Font.FontHeight + i];\r\n-        for(j = 0; j < Font.FontWidth; j++)\r\n-        {\r\n-            if((b << j) & 0x8000)\r\n-            {\r\n-                ssd1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR) color);\r\n-            } else\r\n-            {\r\n-                ssd1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR)!color);\r\n-            }\r\n-        }\r\n-    }\r\n-    \r\n-    // The current space is now taken\r\n-    SSD1306.CurrentX += Font.FontWidth;\r\n-    \r\n-    // Return written char for validation\r\n-    return ch;\r\n-}\r\n-\r\n-// Write full string to screenbuffer\r\n-char ssd1306_WriteString(char* str, FontDef Font, SSD1306_COLOR color)\r\n-{\r\n-    // Write until null-byte\r\n-    while (*str)\r\n-    {\r\n-        if (ssd1306_WriteChar(*str, Font, color) != *str)\r\n-        {\r\n-            // Char could not be written\r\n-            return *str;\r\n-        }\r\n-        \r\n-        // Next char\r\n-        str++;\r\n-    }\r\n-    \r\n-    // Everything ok\r\n-    return *str;\r\n-}\r\n-\r\n-// Position the cursor\r\n-void ssd1306_SetCursor(uint8_t x, uint8_t y)\r\n-{\r\n-    SSD1306.CurrentX = x;\r\n-    SSD1306.CurrentY = y;\r\n-}\r\n-\r\n-// Draw line by Bresenhem's algorithm\r\n-void ssd1306_Line(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, SSD1306_COLOR color)\r\n-{\r\n-    int32_t deltaX = abs(x2 - x1);\r\n-    int32_t deltaY = abs(y2 - y1);\r\n-    int32_t signX = ((x1 < x2) ? 1 : -1);\r\n-    int32_t signY = ((y1 < y2) ? 1 : -1);\r\n-    int32_t error = deltaX - deltaY;\r\n-    int32_t error2;\r\n-    \r\n-    ssd1306_DrawPixel(x2, y2, color);\r\n-    while((x1 != x2) || (y1 != y2))\r\n-    {\r\n-        ssd1306_DrawPixel(x1, y1, color);\r\n-        error2 = error * 2;\r\n-        if(error2 > -deltaY)\r\n-        {\r\n-            error -= deltaY;\r\n-            x1 += signX;\r\n-        }\r\n-        else\r\n-        {\r\n-            /*nothing to do*/\r\n-        }\r\n-        \r\n-        if(error2 < deltaX)\r\n-        {\r\n-            error += deltaX;\r\n-            y1 += signY;\r\n-        }\r\n-        else\r\n-        {\r\n-            /*nothing to do*/\r\n-        }\r\n-    }\r\n-    return;\r\n-}\r\n-//Draw polyline\r\n-void ssd1306_Polyline(const SSD1306_VERTEX *par_vertex, uint16_t par_size, SSD1306_COLOR color)\r\n-{\r\n-    uint16_t i;\r\n-    if(par_vertex != 0)\r\n-    {\r\n-        for(i = 1; i < par_size; i++)\r\n-        {\r\n-            ssd1306_Line(par_vertex[i - 1].x, par_vertex[i - 1].y, par_vertex[i].x, par_vertex[i].y, color);\r\n-        }\r\n-    }\r\n-    else\r\n-    {\r\n-        /*nothing to do*/\r\n-    }\r\n-    return;\r\n-}\r\n-\r\n-/*Convert Degrees to Radians*/\r\n-static float ssd1306_DegToRad(float par_deg)\r\n-{\r\n-    return par_deg * 3.14 / 180.0;\r\n-}\r\n-\r\n-/*Normalize degree to [0;360]*/\r\n-static uint16_t ssd1306_NormalizeTo0_360(uint16_t par_deg)\r\n-{\r\n-    uint16_t loc_angle;\r\n-    if(par_deg <= 360)\r\n-    {\r\n-        loc_angle = par_deg;\r\n-    }\r\n-    else\r\n-    {\r\n-        loc_angle = par_deg % 360;\r\n-        loc_angle = ((par_deg != 0)?par_deg:360);\r\n-    }\r\n-    return loc_angle;\r\n-}\r\n-\r\n-/*DrawArc. Draw angle is beginning from 4 quart of trigonometric circle (3pi/2)\r\n- * start_angle in degree\r\n- * sweep in degree\r\n- */\r\n-void ssd1306_DrawArc(uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle, uint16_t sweep, SSD1306_COLOR color)\r\n-{\r\n-    #define CIRCLE_APPROXIMATION_SEGMENTS 36\r\n-    float approx_degree;\r\n-    uint32_t approx_segments;\r\n-    uint8_t xp1,xp2;\r\n-    uint8_t yp1,yp2;\r\n-    uint32_t count = 0;\r\n-    uint32_t loc_sweep = 0;\r\n-    float rad;\r\n-    \r\n-    loc_sweep = ssd1306_NormalizeTo0_360(sweep);\r\n-    \r\n-    count = (ssd1306_NormalizeTo0_360(start_angle) * CIRCLE_APPROXIMATION_SEGMENTS) / 360;\r\n-    approx_segments = (loc_sweep * CIRCLE_APPROXIMATION_SEGMENTS) / 360;\r\n-    approx_degree = loc_sweep / (float)approx_segments;\r\n-    while(count < approx_segments)\r\n-    {\r\n-        rad = ssd1306_DegToRad(count*approx_degree);\r\n-        xp1 = x + (int8_t)(sin(rad)*radius);\r\n-        yp1 = y + (int8_t)(cos(rad)*radius);    \r\n-        count++;\r\n-        if(count != approx_segments)\r\n-        {\r\n-            rad = ssd1306_DegToRad(count*approx_degree);\r\n-        }\r\n-        else\r\n-        {            \r\n-            rad = ssd1306_DegToRad(loc_sweep);\r\n-        }\r\n-        xp2 = x + (int8_t)(sin(rad)*radius);\r\n-        yp2 = y + (int8_t)(cos(rad)*radius);    \r\n-        ssd1306_Line(xp1,yp1,xp2,yp2,color);\r\n-    }\r\n-    \r\n-    return;\r\n-}\r\n-//Draw circle by Bresenhem's algorithm\r\n-void ssd1306_DrawCircle(uint8_t par_x,uint8_t par_y,uint8_t par_r,SSD1306_COLOR par_color)\r\n-{\r\n-    int32_t x = -par_r;\r\n-    int32_t y = 0;\r\n-    int32_t err = 2 - 2 * par_r;\r\n-    int32_t e2;\r\n-\r\n-    if (par_x >= SSD1306_WIDTH || par_y >= SSD1306_HEIGHT)\r\n-    {\r\n-        return;\r\n-    }\r\n-\r\n-    do {\r\n-      ssd1306_DrawPixel(par_x - x, par_y + y, par_color);\r\n-      ssd1306_DrawPixel(par_x + x, par_y + y, par_color);\r\n-      ssd1306_DrawPixel(par_x + x, par_y - y, par_color);\r\n-      ssd1306_DrawPixel(par_x - x, par_y - y, par_color);\r\n-        e2 = err;\r\n-        if (e2 <= y)\r\n-        {\r\n-            y++;\r\n-            err = err + (y * 2 + 1);\r\n-            if(-x == y && e2 <= x)\r\n-            {\r\n-              e2 = 0;\r\n-            }\r\n-            else\r\n-            {\r\n-              /*nothing to do*/\r\n-            }\r\n-        }\r\n-        else\r\n-        {\r\n-            /*nothing to do*/\r\n-        }\r\n-        if(e2 > x)\r\n-        {\r\n-            x++;\r\n-            err = err + (x * 2 + 1);\r\n-        }\r\n-        else\r\n-        {\r\n-            /*nothing to do*/\r\n-        }\r\n-    } while(x <= 0);\r\n-\r\n-    return;\r\n-}\r\n-\r\n-//Draw rectangle\r\n-void ssd1306_DrawRectangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, SSD1306_COLOR color)\r\n-{\r\n-    ssd1306_Line(x1,y1,x2,y1,color);\r\n-    ssd1306_Line(x2,y1,x2,y2,color);\r\n-    ssd1306_Line(x2,y2,x1,y2,color);\r\n-    ssd1306_Line(x1,y2,x1,y1,color);\r\n-\r\n-    return;\r\n-}\r\n-\r\n-void ssd1306_SetContrast(const uint8_t value)\r\n-{\r\n-    const uint8_t kSetContrastControlRegister = 0x81;\r\n-    ssd1306_WriteCommand(kSetContrastControlRegister);\r\n-    ssd1306_WriteCommand(value);\r\n-}\r\n-\r\n-void ssd1306_SetDisplayOn(const uint8_t on)\r\n-{\r\n-    uint8_t value;\r\n-    if (on)\r\n-    {\r\n-        value = 0xAF;   // Display on\r\n-        SSD1306.DisplayOn = 1;\r\n-    } else \r\n-    {\r\n-        value = 0xAE;   // Display off\r\n-        SSD1306.DisplayOn = 0;\r\n-    }\r\n-    ssd1306_WriteCommand(value);\r\n-}\r\n-\r\n-uint8_t ssd1306_GetDisplayOn()\r\n-{\r\n-    return SSD1306.DisplayOn;\r\n-}\r\n\\ No newline at end of file\n"
                },
                {
                    "date": 1673865320484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,8 @@\n-\n+/*\r\n+ * @Author: rx-ted\r\n+ * @Date: 2023-01-15 16:01:24\r\n+ * @LastEditors: rx-ted\r\n+ * @LastEditTime: 2023-01-16 18:35:14\r\n+ */\r\n+\r\n+#include \"\"\n\\ No newline at end of file\n"
                },
                {
                    "date": 1673865326826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,5 +4,5 @@\n  * @LastEditors: rx-ted\r\n  * @LastEditTime: 2023-01-16 18:35:14\r\n  */\r\n \r\n-#include \"\"\n\\ No newline at end of file\n+#in\n\\ No newline at end of file\n"
                },
                {
                    "date": 1673865334748,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,5 +4,7 @@\n  * @LastEditors: rx-ted\r\n  * @LastEditTime: 2023-01-16 18:35:14\r\n  */\r\n \r\n-#in\n\\ No newline at end of file\n+#ifndef USING\r\n+\r\n+#endif // !USING\n\\ No newline at end of file\n"
                },
                {
                    "date": 1673865345039,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,7 +4,7 @@\n  * @LastEditors: rx-ted\r\n  * @LastEditTime: 2023-01-16 18:35:14\r\n  */\r\n \r\n-#ifndef USING\r\n+#ifndef USING_I2C_SSD1306\r\n \r\n\\ No newline at end of file\n-#endif // !USING\n+#endif // !USING_I2C_SSD1306\n\\ No newline at end of file\n"
                },
                {
                    "date": 1673865350969,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,5 +6,8 @@\n  */\r\n \r\n #ifndef USING_I2C_SSD1306\r\n \r\n+#DEF\r\n+\r\n+\r\n #endif // !USING_I2C_SSD1306\n\\ No newline at end of file\n"
                },
                {
                    "date": 1673865358317,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,8 @@\n  */\r\n \r\n #ifndef USING_I2C_SSD1306\r\n \r\n-#DEF\r\n+#define \r\n \r\n \r\n\\ No newline at end of file\n-#endif // !USING_I2C_SSD1306\n+#endif // !USING_I2C_SSD1306    \n\\ No newline at end of file\n"
                },
                {
                    "date": 1673865365192,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,12 @@\n  * @LastEditors: rx-ted\r\n  * @LastEditTime: 2023-01-16 18:35:14\r\n  */\r\n \r\n+\r\n+\r\n #ifndef USING_I2C_SSD1306\r\n \r\n-#define \r\n \r\n \r\n+\r\n #endif // !USING_I2C_SSD1306    \n\\ No newline at end of file\n"
                },
                {
                    "date": 1673865379764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,13 @@\n /*\r\n  * @Author: rx-ted\r\n  * @Date: 2023-01-15 16:01:24\r\n  * @LastEditors: rx-ted\r\n- * @LastEditTime: 2023-01-16 18:35:14\r\n+ * @LastEditTime: 2023-01-16 18:36:19\r\n  */\r\n \r\n+# ifndef\r\n \r\n-\r\n #ifndef USING_I2C_SSD1306\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1673865396859,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,10 +4,12 @@\n  * @LastEditors: rx-ted\r\n  * @LastEditTime: 2023-01-16 18:36:19\r\n  */\r\n \r\n-# ifndef\r\n+#ifndef __SSD1306_H__\r\n \r\n+#endif // !__SSD1306_H__\r\n+\r\n #ifndef USING_I2C_SSD1306\r\n \r\n \r\n \r\n"
                },
                {
                    "date": 1673865404243,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,12 +6,15 @@\n  */\r\n \r\n #ifndef __SSD1306_H__\r\n \r\n-#endif // !__SSD1306_H__\r\n \r\n+\r\n+\r\n #ifndef USING_I2C_SSD1306\r\n \r\n \r\n \r\n\\ No newline at end of file\n \r\n-#endif // !USING_I2C_SSD1306    \n+#endif // !USING_I2C_SSD1306    \r\n+\r\n+#endif // !__SSD1306_H__\r\n"
                },
                {
                    "date": 1673865412643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,16 +5,16 @@\n  * @LastEditTime: 2023-01-16 18:36:19\r\n  */\r\n \r\n #ifndef __SSD1306_H__\r\n+#define__SSD1306_H__\r\n \r\n \r\n \r\n-\r\n #ifndef USING_I2C_SSD1306\r\n \r\n \r\n \r\n \r\n #endif // !USING_I2C_SSD1306    \r\n \r\n\\ No newline at end of file\n-#endif // !__SSD1306_H__\n+#endif // !__SSD1306_H__\r\n"
                },
                {
                    "date": 1673865418911,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,16 +5,14 @@\n  * @LastEditTime: 2023-01-16 18:36:19\r\n  */\r\n \r\n #ifndef __SSD1306_H__\r\n-#define__SSD1306_H__\r\n+#define __SSD1306_H__\r\n \r\n-\r\n-\r\n #ifndef USING_I2C_SSD1306\r\n \r\n \r\n \r\n \r\n-#endif // !USING_I2C_SSD1306    \r\n+#endif // !USING_I2C_SSD1306\r\n\\ No newline at end of file\n \r\n-#endif // !__SSD1306_H__\n+#endif // !__SSD1306_H__\r\n"
                },
                {
                    "date": 1673865482280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n /*\r\n  * @Author: rx-ted\r\n  * @Date: 2023-01-15 16:01:24\r\n  * @LastEditors: rx-ted\r\n- * @LastEditTime: 2023-01-16 18:36:19\r\n+ * @LastEditTime: 2023-01-16 18:38:02\r\n  */\r\n \r\n #ifndef __SSD1306_H__\r\n #define __SSD1306_H__\r\n@@ -11,8 +11,22 @@\n #ifndef USING_I2C_SSD1306\r\n \r\n \r\n \r\n+void ssd1306_device_find(void)\r\n+{\r\n+    i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n+    if (i2c_bus == RT_NULL)\r\n\\ No newline at end of file\n+    {\r\n+        rt_kprintf(\"can not find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n+        return;\r\n+    }\r\n+    rt_kprintf(\"find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n \r\n+    rt_i2c_bus_device_register(i2c_bus, \"ssd1306\");\r\n+    \r\n+}\r\n+\r\n+\r\n #endif // !USING_I2C_SSD1306\r\n \r\n-#endif // !__SSD1306_H__\n+#endif // !__SSD1306_H__\r\n"
                },
                {
                    "date": 1673865672338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n /*\r\n  * @Author: rx-ted\r\n  * @Date: 2023-01-15 16:01:24\r\n  * @LastEditors: rx-ted\r\n- * @LastEditTime: 2023-01-16 18:38:02\r\n+ * @LastEditTime: 2023-01-16 18:41:12\r\n  */\r\n \r\n #ifndef __SSD1306_H__\r\n #define __SSD1306_H__\r\n@@ -11,8 +11,9 @@\n #ifndef USING_I2C_SSD1306\r\n \r\n \r\n \r\n+\r\n void ssd1306_device_find(void)\r\n {\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n@@ -28,5 +29,5 @@\n \r\n \r\n #endif // !USING_I2C_SSD1306\r\n \r\n-#endif // !__SSD1306_H__\n\\ No newline at end of file\n+#endif // !__SSD1306_H__\r\n"
                },
                {
                    "date": 1673866251308,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,19 +1,19 @@\n /*\r\n  * @Author: rx-ted\r\n  * @Date: 2023-01-15 16:01:24\r\n  * @LastEditors: rx-ted\r\n- * @LastEditTime: 2023-01-16 18:41:12\r\n+ * @LastEditTime: 2023-01-16 18:50:51\r\n  */\r\n \r\n #ifndef __SSD1306_H__\r\n #define __SSD1306_H__\r\n \r\n #ifndef USING_I2C_SSD1306\r\n \r\n \r\n+#include\"i2c\r\n \r\n-\r\n void ssd1306_device_find(void)\r\n {\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n"
                },
                {
                    "date": 1673866273966,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,11 +9,11 @@\n #define __SSD1306_H__\r\n \r\n #ifndef USING_I2C_SSD1306\r\n \r\n+#include \"\"\r\n+#include\"i2c.h\"\r\n \r\n-#include\"i2c\r\n-\r\n void ssd1306_device_find(void)\r\n {\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n"
                },
                {
                    "date": 1673866289175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,10 +9,11 @@\n #define __SSD1306_H__\r\n \r\n #ifndef USING_I2C_SSD1306\r\n \r\n+#include \"i2c_dev.h\"\r\n+#include\"i2c.h\"\r\n #include \"\"\r\n-#include\"i2c.h\"\r\n \r\n void ssd1306_device_find(void)\r\n {\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866347345,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,12 +8,12 @@\n #ifndef __SSD1306_H__\r\n #define __SSD1306_H__\r\n \r\n #ifndef USING_I2C_SSD1306\r\n-\r\n+#include \"drv_gpio.h\"\r\n #include \"i2c_dev.h\"\r\n #include\"i2c.h\"\r\n-#include \"\"\r\n+#include \"n32g4fr_i2c.h\"\r\n \r\n void ssd1306_device_find(void)\r\n {\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866360537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,9 @@\n #ifndef USING_I2C_SSD1306\r\n #include \"drv_gpio.h\"\r\n #include \"i2c_dev.h\"\r\n #include\"i2c.h\"\r\n-#include \"n32g4fr_i2c.h\"\r\n+#include \"n32g4fr_i2c.h\"#include \"pin.h\"\r\n \r\n void ssd1306_device_find(void)\r\n {\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866388941,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,12 +11,14 @@\n #ifndef USING_I2C_SSD1306\r\n #include \"drv_gpio.h\"\r\n #include \"i2c_dev.h\"\r\n #include\"i2c.h\"\r\n-#include \"n32g4fr_i2c.h\"#include \"pin.h\"\r\n+#include \"n32g4fr_i2c.h\"\r\n+#include \"pin.h\"\r\n \r\n void ssd1306_device_find(void)\r\n {\r\n+    rt_device\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n     {\r\n         rt_kprintf(\"can not find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866394219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n #include \"pin.h\"\r\n \r\n void ssd1306_device_find(void)\r\n {\r\n-    rt_device\r\n+    rt_device_i2c\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n     {\r\n         rt_kprintf(\"can not find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866401280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n #include \"pin.h\"\r\n \r\n void ssd1306_device_find(void)\r\n {\r\n-    rt_device_i2c\r\n+rt_find\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n     {\r\n         rt_kprintf(\"can not find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866419797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n /*\r\n  * @Author: rx-ted\r\n  * @Date: 2023-01-15 16:01:24\r\n  * @LastEditors: rx-ted\r\n- * @LastEditTime: 2023-01-16 18:50:51\r\n+ * @LastEditTime: 2023-01-16 18:53:39\r\n  */\r\n \r\n #ifndef __SSD1306_H__\r\n #define __SSD1306_H__\r\n@@ -16,9 +16,9 @@\n #include \"pin.h\"\r\n \r\n void ssd1306_device_find(void)\r\n {\r\n-rt_find\r\n+\r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n     {\r\n         rt_kprintf(\"can not find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866446666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,11 +11,10 @@\n #ifndef USING_I2C_SSD1306\r\n #include \"drv_gpio.h\"\r\n #include \"i2c_dev.h\"\r\n #include\"i2c.h\"\r\n-#include \"n32g4fr_i2c.h\"\r\n-#include \"pin.h\"\r\n \r\n+\r\n void ssd1306_device_find(void)\r\n {\r\n \r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866452682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,13 +8,12 @@\n #ifndef __SSD1306_H__\r\n #define __SSD1306_H__\r\n \r\n #ifndef USING_I2C_SSD1306\r\n-#include \"drv_gpio.h\"\r\n-#include \"i2c_dev.h\"\r\n-#include\"i2c.h\"\r\n \r\n \r\n+\r\n+\r\n void ssd1306_device_find(void)\r\n {\r\n \r\n     i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n"
                },
                {
                    "date": 1673866599615,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n /*\r\n  * @Author: rx-ted\r\n  * @Date: 2023-01-15 16:01:24\r\n  * @LastEditors: rx-ted\r\n- * @LastEditTime: 2023-01-16 18:53:39\r\n+ * @LastEditTime: 2023-01-16 18:56:39\r\n  */\r\n \r\n #ifndef __SSD1306_H__\r\n #define __SSD1306_H__\r\n@@ -15,9 +15,9 @@\n \r\n void ssd1306_device_find(void)\r\n {\r\n \r\n-    i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n+    i2cBus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n     if (i2c_bus == RT_NULL)\r\n     {\r\n         rt_kprintf(\"can not find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n         return;\r\n"
                },
                {
                    "date": 1673866628038,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,24 +8,24 @@\n #ifndef __SSD1306_H__\r\n #define __SSD1306_H__\r\n \r\n #ifndef USING_I2C_SSD1306\r\n+#include<ssd1306.h>\r\n \r\n \r\n \r\n-\r\n void ssd1306_device_find(void)\r\n {\r\n \r\n     i2cBus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n-    if (i2c_bus == RT_NULL)\r\n+    if (i2cBus == RT_NULL)\r\n     {\r\n         rt_kprintf(\"can not find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n         return;\r\n     }\r\n     rt_kprintf(\"find %s device\\n\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n \r\n-    rt_i2c_bus_device_register(i2c_bus, \"ssd1306\");\r\n+    rt_i2c_bus_device_register(i2cBus, \"ssd1306\");\r\n     \r\n }\r\n \r\n \r\n"
                }
            ],
            "date": 1673770639404,
            "name": "Commit-0",
            "content": "/*\r\n * Copyright (c) 2020, RudyLo <luhuadong@163.com>\r\n *\r\n * SPDX-License-Identifier: MIT License\r\n *\r\n * Change Logs:\r\n * Date           Author       Notes\r\n * 2020-11-15     luhuadong    the first version\r\n */\r\n\r\n#include <rtthread.h>\r\n#include <rtdevice.h>\r\n#include <stdlib.h>\r\n#include <string.h>  // For memcpy\r\n#include <math.h>\r\n#include \"ssd1306.h\"\r\n\r\n#include <rtdbg.h>\r\n\r\n#if defined(SSD1306_USE_I2C)\r\n\r\n#define SSD1306_CTRL_CMD     0x00\r\n#define SSD1306_CTRL_DATA    0x40\r\n#define SSD1306_MASK_CONT    (0x1<<7)\r\n\r\nstatic struct rt_i2c_bus_device *i2c_bus;\r\n\r\nvoid ssd1306_Reset(void) \r\n{\r\n    /* for I2C - do nothing */\r\n}\r\n\r\n// Send a byte to the command register\r\nvoid ssd1306_WriteCommand(uint8_t byte) \r\n{\r\n#if PKG_USING_SSD1306_HW_I2C\r\n    HAL_I2C_Mem_Write(&SSD1306_I2C_PORT, SSD1306_I2C_ADDR, 0x00, 1, &byte, 1, HAL_MAX_DELAY);\r\n#else\r\n    uint8_t buf[2] = {SSD1306_CTRL_CMD, byte};\r\n    rt_i2c_master_send(i2c_bus, SSD1306_I2C_ADDR, RT_I2C_WR, buf, 2);\r\n#endif\r\n}\r\n\r\n// Send data\r\nvoid ssd1306_WriteData(uint8_t* buffer, size_t buff_size) \r\n{\r\n#if PKG_USING_SSD1306_HW_I2C\r\n    HAL_I2C_Mem_Write(&SSD1306_I2C_PORT, SSD1306_I2C_ADDR, 0x40, 1, buffer, buff_size, HAL_MAX_DELAY);\r\n#else\r\n    for (int i=0; i<buff_size; i++)\r\n    {\r\n        uint8_t buf[2] = {SSD1306_CTRL_DATA, buffer[i]};\r\n        rt_i2c_master_send(i2c_bus, SSD1306_I2C_ADDR, RT_I2C_WR, buf, 2);\r\n    }\r\n#endif\r\n}\r\n\r\n#elif defined(SSD1306_USE_SPI)\r\n\r\nvoid ssd1306_Reset(void) \r\n{\r\n    // CS = High (not selected)\r\n    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_SET);\r\n\r\n    // Reset the OLED\r\n    HAL_GPIO_WritePin(SSD1306_Reset_Port, SSD1306_Reset_Pin, GPIO_PIN_RESET);\r\n    rt_thread_mdelay(10);\r\n    HAL_GPIO_WritePin(SSD1306_Reset_Port, SSD1306_Reset_Pin, GPIO_PIN_SET);\r\n    rt_thread_mdelay(10);\r\n}\r\n\r\n// Send a byte to the command register\r\nvoid ssd1306_WriteCommand(uint8_t byte) \r\n{\r\n    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_RESET); // select OLED\r\n    HAL_GPIO_WritePin(SSD1306_DC_Port, SSD1306_DC_Pin, GPIO_PIN_RESET); // command\r\n    HAL_SPI_Transmit(&SSD1306_SPI_PORT, (uint8_t *) &byte, 1, HAL_MAX_DELAY);\r\n    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_SET); // un-select OLED\r\n}\r\n\r\n// Send data\r\nvoid ssd1306_WriteData(uint8_t* buffer, size_t buff_size) \r\n{\r\n    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_RESET); // select OLED\r\n    HAL_GPIO_WritePin(SSD1306_DC_Port, SSD1306_DC_Pin, GPIO_PIN_SET); // data\r\n    HAL_SPI_Transmit(&SSD1306_SPI_PORT, buffer, buff_size, HAL_MAX_DELAY);\r\n    HAL_GPIO_WritePin(SSD1306_CS_Port, SSD1306_CS_Pin, GPIO_PIN_SET); // un-select OLED\r\n}\r\n\r\n#else\r\n#error \"You should define SSD1306_USE_SPI or SSD1306_USE_I2C macro\"\r\n#endif\r\n\r\n\r\n// Screenbuffer\r\nstatic uint8_t SSD1306_Buffer[SSD1306_BUFFER_SIZE];\r\n\r\n// Screen object\r\nstatic SSD1306_t SSD1306;\r\n\r\n/* Fills the Screenbuffer with values from a given buffer of a fixed length */\r\nSSD1306_Error_t ssd1306_FillBuffer(uint8_t* buf, uint32_t len) \r\n{\r\n    SSD1306_Error_t ret = SSD1306_ERR;\r\n    if (len <= SSD1306_BUFFER_SIZE) {\r\n        memcpy(SSD1306_Buffer,buf,len);\r\n        ret = SSD1306_OK;\r\n    }\r\n    return ret;\r\n}\r\n\r\n// Initialize the oled screen\r\nvoid ssd1306_Init(void) \r\n{\r\n#if defined(SSD1306_USE_I2C)\r\n    i2c_bus = (struct rt_i2c_bus_device *)rt_device_find(PKG_USING_SSD1306_I2C_BUS_NAME);\r\n    if (i2c_bus == RT_NULL)\r\n    {\r\n        LOG_E(\"can not find %s device\", PKG_USING_SSD1306_I2C_BUS_NAME);\r\n        return;\r\n    }\r\n#endif\r\n\r\n    // Reset OLED\r\n    ssd1306_Reset();\r\n\r\n    // Wait for the screen to boot\r\n    rt_thread_mdelay(100);\r\n\r\n    // Init OLED\r\n    ssd1306_SetDisplayOn(0); //display off\r\n\r\n    ssd1306_WriteCommand(0x20); //Set Memory Addressing Mode\r\n    ssd1306_WriteCommand(0x00); // 00b,Horizontal Addressing Mode; 01b,Vertical Addressing Mode;\r\n                                // 10b,Page Addressing Mode (RESET); 11b,Invalid\r\n\r\n    ssd1306_WriteCommand(0xB0); //Set Page Start Address for Page Addressing Mode,0-7\r\n\r\n#ifdef SSD1306_MIRROR_VERT\r\n    ssd1306_WriteCommand(0xC0); // Mirror vertically\r\n#else\r\n    ssd1306_WriteCommand(0xC8); //Set COM Output Scan Direction\r\n#endif\r\n\r\n    ssd1306_WriteCommand(0x00); //---set low column address\r\n    ssd1306_WriteCommand(0x10); //---set high column address\r\n\r\n    ssd1306_WriteCommand(0x40); //--set start line address - CHECK\r\n\r\n    ssd1306_SetContrast(0xFF);\r\n\r\n#ifdef SSD1306_MIRROR_HORIZ\r\n    ssd1306_WriteCommand(0xA0); // Mirror horizontally\r\n#else\r\n    ssd1306_WriteCommand(0xA1); //--set segment re-map 0 to 127 - CHECK\r\n#endif\r\n\r\n#ifdef SSD1306_INVERSE_COLOR\r\n    ssd1306_WriteCommand(0xA7); //--set inverse color\r\n#else\r\n    ssd1306_WriteCommand(0xA6); //--set normal color\r\n#endif\r\n\r\n// Set multiplex ratio.\r\n#if (SSD1306_HEIGHT == 128)\r\n    // Found in the Luma Python lib for SH1106.\r\n    ssd1306_WriteCommand(0xFF);\r\n#else\r\n    ssd1306_WriteCommand(0xA8); //--set multiplex ratio(1 to 64) - CHECK\r\n#endif\r\n\r\n#if (SSD1306_HEIGHT == 32)\r\n    ssd1306_WriteCommand(0x1F); //\r\n#elif (SSD1306_HEIGHT == 64)\r\n    ssd1306_WriteCommand(0x3F); //\r\n#elif (SSD1306_HEIGHT == 128)\r\n    ssd1306_WriteCommand(0x3F); // Seems to work for 128px high displays too.\r\n#else\r\n#error \"Only 32, 64, or 128 lines of height are supported!\"\r\n#endif\r\n\r\n    ssd1306_WriteCommand(0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content\r\n\r\n    ssd1306_WriteCommand(0xD3); //-set display offset - CHECK\r\n    ssd1306_WriteCommand(0x00); //-not offset\r\n\r\n    ssd1306_WriteCommand(0xD5); //--set display clock divide ratio/oscillator frequency\r\n    ssd1306_WriteCommand(0xF0); //--set divide ratio\r\n\r\n    ssd1306_WriteCommand(0xD9); //--set pre-charge period\r\n    ssd1306_WriteCommand(0x22); //\r\n\r\n    ssd1306_WriteCommand(0xDA); //--set com pins hardware configuration - CHECK\r\n#if (SSD1306_HEIGHT == 32)\r\n    ssd1306_WriteCommand(0x02);\r\n#elif (SSD1306_HEIGHT == 64)\r\n    ssd1306_WriteCommand(0x12);\r\n#elif (SSD1306_HEIGHT == 128)\r\n    ssd1306_WriteCommand(0x12);\r\n#else\r\n#error \"Only 32, 64, or 128 lines of height are supported!\"\r\n#endif\r\n\r\n    ssd1306_WriteCommand(0xDB); //--set vcomh\r\n    ssd1306_WriteCommand(0x20); //0x20,0.77xVcc\r\n\r\n    ssd1306_WriteCommand(0x8D); //--set DC-DC enable\r\n    ssd1306_WriteCommand(0x14); //\r\n    ssd1306_SetDisplayOn(1); //--turn on SSD1306 panel\r\n\r\n    // Clear screen\r\n    ssd1306_Fill(Black);\r\n    \r\n    // Flush buffer to screen\r\n    ssd1306_UpdateScreen();\r\n    \r\n    // Set default values for screen object\r\n    SSD1306.CurrentX = 0;\r\n    SSD1306.CurrentY = 0;\r\n    \r\n    SSD1306.Initialized = 1;\r\n}\r\n\r\n// Fill the whole screen with the given color\r\nvoid ssd1306_Fill(SSD1306_COLOR color) \r\n{\r\n    /* Set memory */\r\n    uint32_t i;\r\n\r\n    for(i = 0; i < sizeof(SSD1306_Buffer); i++) \r\n    {\r\n        SSD1306_Buffer[i] = (color == Black) ? 0x00 : 0xFF;\r\n    }\r\n}\r\n\r\n// Write the screenbuffer with changed to the screen\r\nvoid ssd1306_UpdateScreen(void) \r\n{\r\n    // Write data to each page of RAM. Number of pages\r\n    // depends on the screen height:\r\n    //\r\n    //  * 32px   ==  4 pages\r\n    //  * 64px   ==  8 pages\r\n    //  * 128px  ==  16 pages\r\n    for(uint8_t i = 0; i < SSD1306_HEIGHT/8; i++) \r\n    {\r\n        ssd1306_WriteCommand(0xB0 + i); // Set the current RAM page address.\r\n        ssd1306_WriteCommand(0x00);\r\n        ssd1306_WriteCommand(0x10);\r\n        ssd1306_WriteData(&SSD1306_Buffer[SSD1306_WIDTH*i],SSD1306_WIDTH);\r\n    }\r\n}\r\n\r\n//    Draw one pixel in the screenbuffer\r\n//    X => X Coordinate\r\n//    Y => Y Coordinate\r\n//    color => Pixel color\r\nvoid ssd1306_DrawPixel(uint8_t x, uint8_t y, SSD1306_COLOR color) \r\n{\r\n    if(x >= SSD1306_WIDTH || y >= SSD1306_HEIGHT)\r\n    {\r\n        // Don't write outside the buffer\r\n        return;\r\n    }\r\n    \r\n    // Check if pixel should be inverted\r\n    if(SSD1306.Inverted)\r\n    {\r\n        color = (SSD1306_COLOR)!color;\r\n    }\r\n    \r\n    // Draw in the right color\r\n    if(color == White)\r\n    {\r\n        SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] |= 1 << (y % 8);\r\n    } else\r\n    {\r\n        SSD1306_Buffer[x + (y / 8) * SSD1306_WIDTH] &= ~(1 << (y % 8));\r\n    }\r\n}\r\n\r\n// Draw 1 char to the screen buffer\r\n// ch       => char om weg te schrijven\r\n// Font     => Font waarmee we gaan schrijven\r\n// color    => Black or White\r\nchar ssd1306_WriteChar(char ch, FontDef Font, SSD1306_COLOR color) \r\n{\r\n    uint32_t i, b, j;\r\n    \r\n    // Check if character is valid\r\n    if (ch < 32 || ch > 126)\r\n        return 0;\r\n    \r\n    // Check remaining space on current line\r\n    if (SSD1306_WIDTH < (SSD1306.CurrentX + Font.FontWidth) ||\r\n        SSD1306_HEIGHT < (SSD1306.CurrentY + Font.FontHeight))\r\n    {\r\n        // Not enough space on current line\r\n        return 0;\r\n    }\r\n    \r\n    // Use the font to write\r\n    for(i = 0; i < Font.FontHeight; i++)\r\n    {\r\n        b = Font.data[(ch - 32) * Font.FontHeight + i];\r\n        for(j = 0; j < Font.FontWidth; j++)\r\n        {\r\n            if((b << j) & 0x8000)\r\n            {\r\n                ssd1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR) color);\r\n            } else\r\n            {\r\n                ssd1306_DrawPixel(SSD1306.CurrentX + j, (SSD1306.CurrentY + i), (SSD1306_COLOR)!color);\r\n            }\r\n        }\r\n    }\r\n    \r\n    // The current space is now taken\r\n    SSD1306.CurrentX += Font.FontWidth;\r\n    \r\n    // Return written char for validation\r\n    return ch;\r\n}\r\n\r\n// Write full string to screenbuffer\r\nchar ssd1306_WriteString(char* str, FontDef Font, SSD1306_COLOR color)\r\n{\r\n    // Write until null-byte\r\n    while (*str)\r\n    {\r\n        if (ssd1306_WriteChar(*str, Font, color) != *str)\r\n        {\r\n            // Char could not be written\r\n            return *str;\r\n        }\r\n        \r\n        // Next char\r\n        str++;\r\n    }\r\n    \r\n    // Everything ok\r\n    return *str;\r\n}\r\n\r\n// Position the cursor\r\nvoid ssd1306_SetCursor(uint8_t x, uint8_t y)\r\n{\r\n    SSD1306.CurrentX = x;\r\n    SSD1306.CurrentY = y;\r\n}\r\n\r\n// Draw line by Bresenhem's algorithm\r\nvoid ssd1306_Line(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, SSD1306_COLOR color)\r\n{\r\n    int32_t deltaX = abs(x2 - x1);\r\n    int32_t deltaY = abs(y2 - y1);\r\n    int32_t signX = ((x1 < x2) ? 1 : -1);\r\n    int32_t signY = ((y1 < y2) ? 1 : -1);\r\n    int32_t error = deltaX - deltaY;\r\n    int32_t error2;\r\n    \r\n    ssd1306_DrawPixel(x2, y2, color);\r\n    while((x1 != x2) || (y1 != y2))\r\n    {\r\n        ssd1306_DrawPixel(x1, y1, color);\r\n        error2 = error * 2;\r\n        if(error2 > -deltaY)\r\n        {\r\n            error -= deltaY;\r\n            x1 += signX;\r\n        }\r\n        else\r\n        {\r\n            /*nothing to do*/\r\n        }\r\n        \r\n        if(error2 < deltaX)\r\n        {\r\n            error += deltaX;\r\n            y1 += signY;\r\n        }\r\n        else\r\n        {\r\n            /*nothing to do*/\r\n        }\r\n    }\r\n    return;\r\n}\r\n//Draw polyline\r\nvoid ssd1306_Polyline(const SSD1306_VERTEX *par_vertex, uint16_t par_size, SSD1306_COLOR color)\r\n{\r\n    uint16_t i;\r\n    if(par_vertex != 0)\r\n    {\r\n        for(i = 1; i < par_size; i++)\r\n        {\r\n            ssd1306_Line(par_vertex[i - 1].x, par_vertex[i - 1].y, par_vertex[i].x, par_vertex[i].y, color);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        /*nothing to do*/\r\n    }\r\n    return;\r\n}\r\n\r\n/*Convert Degrees to Radians*/\r\nstatic float ssd1306_DegToRad(float par_deg)\r\n{\r\n    return par_deg * 3.14 / 180.0;\r\n}\r\n\r\n/*Normalize degree to [0;360]*/\r\nstatic uint16_t ssd1306_NormalizeTo0_360(uint16_t par_deg)\r\n{\r\n    uint16_t loc_angle;\r\n    if(par_deg <= 360)\r\n    {\r\n        loc_angle = par_deg;\r\n    }\r\n    else\r\n    {\r\n        loc_angle = par_deg % 360;\r\n        loc_angle = ((par_deg != 0)?par_deg:360);\r\n    }\r\n    return loc_angle;\r\n}\r\n\r\n/*DrawArc. Draw angle is beginning from 4 quart of trigonometric circle (3pi/2)\r\n * start_angle in degree\r\n * sweep in degree\r\n */\r\nvoid ssd1306_DrawArc(uint8_t x, uint8_t y, uint8_t radius, uint16_t start_angle, uint16_t sweep, SSD1306_COLOR color)\r\n{\r\n    #define CIRCLE_APPROXIMATION_SEGMENTS 36\r\n    float approx_degree;\r\n    uint32_t approx_segments;\r\n    uint8_t xp1,xp2;\r\n    uint8_t yp1,yp2;\r\n    uint32_t count = 0;\r\n    uint32_t loc_sweep = 0;\r\n    float rad;\r\n    \r\n    loc_sweep = ssd1306_NormalizeTo0_360(sweep);\r\n    \r\n    count = (ssd1306_NormalizeTo0_360(start_angle) * CIRCLE_APPROXIMATION_SEGMENTS) / 360;\r\n    approx_segments = (loc_sweep * CIRCLE_APPROXIMATION_SEGMENTS) / 360;\r\n    approx_degree = loc_sweep / (float)approx_segments;\r\n    while(count < approx_segments)\r\n    {\r\n        rad = ssd1306_DegToRad(count*approx_degree);\r\n        xp1 = x + (int8_t)(sin(rad)*radius);\r\n        yp1 = y + (int8_t)(cos(rad)*radius);    \r\n        count++;\r\n        if(count != approx_segments)\r\n        {\r\n            rad = ssd1306_DegToRad(count*approx_degree);\r\n        }\r\n        else\r\n        {            \r\n            rad = ssd1306_DegToRad(loc_sweep);\r\n        }\r\n        xp2 = x + (int8_t)(sin(rad)*radius);\r\n        yp2 = y + (int8_t)(cos(rad)*radius);    \r\n        ssd1306_Line(xp1,yp1,xp2,yp2,color);\r\n    }\r\n    \r\n    return;\r\n}\r\n//Draw circle by Bresenhem's algorithm\r\nvoid ssd1306_DrawCircle(uint8_t par_x,uint8_t par_y,uint8_t par_r,SSD1306_COLOR par_color)\r\n{\r\n    int32_t x = -par_r;\r\n    int32_t y = 0;\r\n    int32_t err = 2 - 2 * par_r;\r\n    int32_t e2;\r\n\r\n    if (par_x >= SSD1306_WIDTH || par_y >= SSD1306_HEIGHT)\r\n    {\r\n        return;\r\n    }\r\n\r\n    do {\r\n      ssd1306_DrawPixel(par_x - x, par_y + y, par_color);\r\n      ssd1306_DrawPixel(par_x + x, par_y + y, par_color);\r\n      ssd1306_DrawPixel(par_x + x, par_y - y, par_color);\r\n      ssd1306_DrawPixel(par_x - x, par_y - y, par_color);\r\n        e2 = err;\r\n        if (e2 <= y)\r\n        {\r\n            y++;\r\n            err = err + (y * 2 + 1);\r\n            if(-x == y && e2 <= x)\r\n            {\r\n              e2 = 0;\r\n            }\r\n            else\r\n            {\r\n              /*nothing to do*/\r\n            }\r\n        }\r\n        else\r\n        {\r\n            /*nothing to do*/\r\n        }\r\n        if(e2 > x)\r\n        {\r\n            x++;\r\n            err = err + (x * 2 + 1);\r\n        }\r\n        else\r\n        {\r\n            /*nothing to do*/\r\n        }\r\n    } while(x <= 0);\r\n\r\n    return;\r\n}\r\n\r\n//Draw rectangle\r\nvoid ssd1306_DrawRectangle(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, SSD1306_COLOR color)\r\n{\r\n    ssd1306_Line(x1,y1,x2,y1,color);\r\n    ssd1306_Line(x2,y1,x2,y2,color);\r\n    ssd1306_Line(x2,y2,x1,y2,color);\r\n    ssd1306_Line(x1,y2,x1,y1,color);\r\n\r\n    return;\r\n}\r\n\r\nvoid ssd1306_SetContrast(const uint8_t value)\r\n{\r\n    const uint8_t kSetContrastControlRegister = 0x81;\r\n    ssd1306_WriteCommand(kSetContrastControlRegister);\r\n    ssd1306_WriteCommand(value);\r\n}\r\n\r\nvoid ssd1306_SetDisplayOn(const uint8_t on)\r\n{\r\n    uint8_t value;\r\n    if (on)\r\n    {\r\n        value = 0xAF;   // Display on\r\n        SSD1306.DisplayOn = 1;\r\n    } else \r\n    {\r\n        value = 0xAE;   // Display off\r\n        SSD1306.DisplayOn = 0;\r\n    }\r\n    ssd1306_WriteCommand(value);\r\n}\r\n\r\nuint8_t ssd1306_GetDisplayOn()\r\n{\r\n    return SSD1306.DisplayOn;\r\n}\r\n"
        }
    ]
}